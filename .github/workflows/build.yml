package me.galaxy.homingbow;

import org.bukkit.Bukkit;
import org.bukkit.NamespacedKey;
import org.bukkit.World;
import org.bukkit.configuration.file.FileConfiguration;
import org.bukkit.entity.AbstractArrow;
import org.bukkit.entity.ArmorStand;
import org.bukkit.entity.LivingEntity;
import org.bukkit.entity.Player;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.EntityShootBowEvent;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.ItemMeta;
import org.bukkit.persistence.PersistentDataType;
import org.bukkit.plugin.java.JavaPlugin;
import org.bukkit.projectiles.ProjectileSource;
import org.bukkit.util.Vector;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

public class HomingBowPlugin extends JavaPlugin implements Listener {

    private final Set<UUID> arrows = ConcurrentHashMap.newKeySet();
    private final Map<UUID, Long> expireAtMillis = new ConcurrentHashMap<>();

    private NamespacedKey key;

    private int customModelData;

    private boolean enabled;
    private double range;
    private double turnRate;

    private double arrowSpeed;
    private long lifetimeMillis;
    private boolean hoverWhenNoTarget;

    private boolean ignoreShooter;
    private boolean ignoreTamed;
    private boolean ignoreArmorStands;

    private boolean avoidPlayersEnabled;
    private double avoidPlayersRadius;

    @Override
    public void onEnable() {
        saveDefaultConfig();
        key = new NamespacedKey(this, "homing");
        loadConfigValues();
        Bukkit.getPluginManager().registerEvents(this, this);
        startTask();
        getLogger().info("HomingBow enabled (hover + lifetime).");
    }

    private void loadConfigValues() {
        reloadConfig();
        FileConfiguration c = getConfig();

        customModelData = c.getInt("bow_match.custom_model_data", 0);

        enabled = c.getBoolean("homing.enabled", true);
        range = c.getDouble("homing.range", 25.0);
        turnRate = clamp(c.getDouble("homing.turn_rate", 0.22), 0.01, 0.95);

        arrowSpeed = c.getDouble("homing.arrow_speed", 1.6);
        int lifetimeSeconds = c.getInt("homing.lifetime_seconds", 10);
        lifetimeMillis = Math.max(1, lifetimeSeconds) * 1000L;

        hoverWhenNoTarget = c.getBoolean("homing.hover_when_no_target", true);

        ignoreShooter = c.getBoolean("targets.ignore_shooter", true);
        ignoreTamed = c.getBoolean("targets.ignore_tamed", true);
        ignoreArmorStands = c.getBoolean("targets.ignore_armor_stands", true);

        avoidPlayersEnabled = c.getBoolean("avoid_players.enabled", true);
        avoidPlayersRadius = c.getDouble("avoid_players.radius", 1.5);
    }

    @EventHandler
    public void onShoot(EntityShootBowEvent e) {
        if (!enabled) return;

        ItemStack bow = e.getBow();
        if (bow == null) return;

        ItemMeta meta = bow.getItemMeta();
        if (meta == null || !meta.hasCustomModelData()) return;
        if (meta.getCustomModelData() != customModelData) return;

        if (e.getProjectile() instanceof AbstractArrow arrow) {
            // ✅ Lebegjen: ne essen le
            arrow.setGravity(false);

            // Ha spammelsz, akkor se "pickupolható" szemét legyen
            try { arrow.setPickupStatus(AbstractArrow.PickupStatus.DISALLOWED); } catch (Throwable ignored) {}

            arrow.getPersistentDataContainer().set(key, PersistentDataType.BYTE, (byte) 1);
            arrows.add(arrow.getUniqueId());
            expireAtMillis.put(arrow.getUniqueId(), System.currentTimeMillis() + lifetimeMillis);
        }
    }

    private void startTask() {
        Bukkit.getScheduler().runTaskTimer(this, () -> {
            if (!enabled) return;

            Iterator<UUID> it = arrows.iterator();
            while (it.hasNext()) {
                UUID id = it.next();
                AbstractArrow arrow = findArrow(id);

                // lejárt idő / nem létezik
                Long exp = expireAtMillis.get(id);
                if (arrow == null || arrow.isDead() || !arrow.isValid() || exp == null || System.currentTimeMillis() >= exp) {
                    if (arrow != null && arrow.isValid()) arrow.remove();
                    it.remove();
                    expireAtMillis.remove(id);
                    continue;
                }

                // mindig lebegjen
                arrow.setGravity(false);

                LivingEntity target = findMobTarget(arrow);
                if (target == null) {
                    if (hoverWhenNoTarget) {
                        arrow.setVelocity(new Vector(0, 0, 0)); // lebeg, amíg talál mobot
                    }
                    continue;
                }

                Vector to = target.getEyeLocation().toVector().subtract(arrow.getLocation().toVector());
                if (to.lengthSquared() < 1e-6) continue;

                Vector desiredDir = to.normalize();
                Vector currentVel = arrow.getVelocity();
                Vector currentDir = (currentVel.lengthSquared() < 1e-6) ? desiredDir : currentVel.clone().normalize();

                Vector newDir = currentDir.multiply(1.0 - turnRate).add(desiredDir.multiply(turnRate));
                if (newDir.lengthSquared() < 1e-6) continue;

                newDir.normalize();
                arrow.setVelocity(newDir.multiply(arrowSpeed));
            }
        }, 1L, 1L);
    }

    private AbstractArrow findArrow(UUID id) {
        for (World w : Bukkit.getWorlds()) {
            for (AbstractArrow a : w.getEntitiesByClass(AbstractArrow.class)) {
                if (a.getUniqueId().equals(id)) return a;
            }
        }
        return null;
    }

    // HARD LOCK: only mobs. Never target players.
    private LivingEntity findMobTarget(AbstractArrow arrow) {
        double best = range * range;
        LivingEntity chosen = null;

        ProjectileSource src = arrow.getShooter();
        LivingEntity shooter = (src instanceof LivingEntity le) ? le : null;

        for (LivingEntity e : arrow.getWorld().getLivingEntities()) {

            if (e instanceof Player) continue; // ❌ játékos soha

            if (ignoreArmorStands && e instanceof ArmorStand) continue;
            if (e.isDead() || !e.isValid()) continue;

            if (ignoreShooter && shooter != null && e.getUniqueId().equals(shooter.getUniqueId())) continue;

            if (ignoreTamed) {
                try {
                    if (e instanceof org.bukkit.entity.Tameable t && t.isTamed()) continue;
                } catch (Throwable ignored) {}
            }

            double d2 = e.getLocation().distanceSquared(arrow.getLocation());
            if (d2 >= best) continue;

            if (avoidPlayersEnabled && segmentNearAnyPlayer(
                    arrow.getLocation().toVector(),
                    e.getEyeLocation().toVector(),
                    avoidPlayersRadius,
                    arrow.getWorld())) {
                continue;
            }

            best = d2;
            chosen = e;
        }

        return chosen;
    }

    private boolean segmentNearAnyPlayer(Vector a, Vector b, double radius, World world) {
        Vector ab = b.clone().subtract(a);
        double abLen2 = ab.lengthSquared();
        if (abLen2 < 1e-6) return false;

        double radius2 = radius * radius;

        for (Player p : world.getPlayers()) {
            Vector pPos = p.getEyeLocation().toVector();
            Vector ap = pPos.clone().subtract(a);

            double t = ap.dot(ab) / abLen2;
            if (t < 0.0) t = 0.0;
            if (t > 1.0) t = 1.0;

            Vector closest = a.clone().add(ab.clone().multiply(t));
            double dist2 = pPos.distanceSquared(closest);

            if (dist2 <= radius2) return true;
        }
        return false;
    }

    private static double clamp(double v, double min, double max) {
        return Math.max(min, Math.min(max, v));
    }

    @Override
    public boolean onCommand(org.bukkit.command.CommandSender sender, org.bukkit.command.Command command, String label, String[] args) {
        if (command.getName().equalsIgnoreCase("homingbowreload")) {
            if (!sender.hasPermission("homingbow.admin")) {
                sender.sendMessage("§cNincs jogod.");
                return true;
            }
            loadConfigValues();
            sender.sendMessage("§aHomingBow újratöltve.");
            return true;
        }
        return false;
    }
}
